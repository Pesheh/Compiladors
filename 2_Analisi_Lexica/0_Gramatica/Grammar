Ada:
	- ___: integer;
	- ___: character;
	- ___: boolean;
	- ___: access _TYPE_;

	- type ___ is [record][new][access] ______ [end record];
	- ___: array ( _RANGE_) of _TYPE_;
	- _ACCESS_TYPE_.all-> 	access to the variables pointed byt the access type.
	
	- if ___ then ___ end if;
	- case ___ is
		when ___ => ; ...when ___ => ;
	  end case;
	- while ___ loop ___ end loop;
	- exception
		when ___ => ; ... when => ;
	
	- procedure ___ ( ___ : [in] [out] ___ ...) is
		...
	  begin
		...
	  end ____;
	- function ___ ( ___: [in] [out] ___ ...) return ___ is
		...
	  begin
		...
		return ____;
	  end ____;
	
	- ___ and [then] ___
	- ___ or ___

	--Alpha no serian solo A-Z, a-z y 0-9, siendo todo lo demas terminales?
	--** == elevado a ..
	Alpha= { '(', ')', '+', '*', '-', '/','%',':',';','"',''','=','>', '<','<=','>=','/=',':=','--',A-Z,a-z,0-9,'.',',','\n','\0'...
	T={while,loop, end loop, if, then, end if,else, elsif, is, array,range,of, type,new,record, end record,and, or,procedure,begin,end,
	 in, out, return, function}
	

	{INIT} 		->	{INITFUNC} 
			|	{INITPROC}

	{INITPROC} 	->	procedure {INDENTIF_P} is {BLOC_PROC}

	{INITFUNC} 	->	function {IDENTIF_P} return {TERME} is {BLOC_FUNC}

	{BLOC_PROC} 	->	{DECLAR} begin {BLOC_I} end {IDENTIF_P};

	{BLOC_FUNC} 	->	{DECLAR} begin {BLOC_I} return {TERME}; end {IDENTIF_P};

	{BLOC_I} 	->	{S_ITER}										
			|	{S_COND}										
			|	{S_ASSIGN};{BLOC_I}
			|	{S_CRIDA};{BLOC_I}
			|	null;
	
	{DECLAR}	->	{INIT}
			|	{S_DECLAR_V/A}
			|	{S_DECLAR_T}
			|	lambda

	{DECLAR_2}	->	{IDENTIF},{DECLAR_2} 
			|	{IDENTIF}			

	{S_DECLAR_V/A} 	->	{IDENTIF}:{TIPUS};{S_DECLAR_V/A} 
			| 	{IDENTIF},{DECLAR_2}:{TIPUS};{S_DECLAR_V/A}		
			|	{IDENTIF}: array ({ARRAY_R}) of {TIPUS};{S_DECLAR_V/A} 					
-- Seria correcte definir-ho a aquest nivell? Seria adequat posar-ho enlloc de {S_DECLAR_V/A}?
			|	{DECLAR} 

	{S_DECLAR_T}	->	type {IDENTIF} is {S_DECLAR_T_2};{S_DECLAR_T}
			|	{DECLAR} 

	{S_DECLAR_T_2}	->	record {S_DECLAR_RECORD} end record 	
			| 	new {TIPUS}
	
	{S_DECLAR_RECORD}->	{IDENTIF}:{TIPUS};{S_DECLAR_RECORD}
                        |       {IDENTIF},{DECLAR_2}:{TIPUS};{S_DECLAR_RECORD}
                        |       {IDENTIF}: array ({ARRAY_R}) of {TIPUS};{S_DECLAR_RECORD} --?

	{ARRAY_R}	->	{TIPUS} range {ENT}..{ENT} 
			| 	{TIPUS} range {ENT}..{ENT}, {ARRAY_R}
	
	{S_ITER}	->	while {COND} loop {BLOC_I} end loop;

	{S_COND}	->	if {COND} then {BLOC_I} {S_COND_2}

	{S_COND_2}	->	end if; 
			| 	else {BLOC_I} end if;

	{S_ASSIGN}	->	{IDENTIF}:={TERME}

	{S_CRIDA}	->	{IDENTIF_P}

	{IDENTIF_P}	->	{IDENTIF}({ARGS}) 
			| 	{IDENTIF}

	{IDENTIF}	->	{CHAR_ID}

	-- Faltaria afegir '_' entre paraules? (es pot fer a nivell de gramatica?)

	{CHAR_ID}	->	([a..z] | [A..Z]) 
			|	([a..z] | [A..Z]){DIG_ID}
			|	{DIG_ID}

	{DIG_ID}	->	[0..9] 
			|	[0..9]{CHAR_ID}
			| 	{CHAR_ID} 
			| 	lambda

	{ARGS}		->	{IDENTIF}: {I_O} {TIPUS} 
			| 	{DECLAR_2},{IDENTIF}: {I_O} {TIPUS} 
			| 	{ARGS_I}

	{ARGS_I}	->	{IDENTIF}: {I_O} {TIPUS};{ARGS} 
			| 	{DECLAR_2},{IDENTIF}: {I_O} {TIPUS};{ARGS}

	{COND}		->	({EVAL}) 
			| 	{EVAL}  
			| 	not ({EVAL})

	-- Falta afegir les opcions amb parentesis a tots els nivells i la negacio de la var inmediata sense parentesis
	-- Tambe es important remarcar que aixi es podrien crear expressions tipus:
	-- (1=1)<not(1/=1), etc. Suposo que a l'etapa d'analisi sintactic es controlen

	{EVAL}		->	{EXPR} and {COND} 
			|	{EXPR} and then {COND}
			|	{EXPR} or {COND}
			|	{EXPR}
			|	not ({EXPR})

	{EXPR}		->	{TERME} < {EVAL}
			|	{TERME} > {EVAL}
			|	{TERME} <= {EVAL}
			|	{TERME} >= {EVAL}
			|	{TERME} = {EVAL}
			|	{TERME} /= {EVAL}		
			|	{TERME}	

	{TERME}		->	{FACT} * {EXPR} 
			| 	{FACT} / {EXPR} 
			| 	{FACT} % {EXPR} 
			| 	{FACT}

	{FACT}		->	{OPER} + {TERME} 
			| 	{OPER} - {TERME} 
			| 	{OPER}

	{OPER}		->	{ENT}
			|	{IDENTIF} 
			| 	({IDENTIF}) 

	{ENT}		->	{OPER_NUM}
			|	-{OPER_NUM} --Realment no hauriem de permetre que es fes un -0. <- FIX IT

	-- Cal afegir la feature de: 1_123_123?
	{OPER_NUM}	->	0
			|	[1..9]{OPER_NUM_2}

	{OPER_NUM_2}	->	[0..9]{OPER_NUM_2}
			|	lambda

	{TIPUS}		->	integer 
			| 	character 
			| 	boolean
	
	{I_O}		->	in 
			| 	out 
			| 	in out
