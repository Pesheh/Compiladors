Ada:
	- ___: integer;
	- ___: character;
	- ___: boolean;
	- ___: access _TYPE_;

	- type ___ is [record][new][access] ______ [end record];
	- ___: array ( _RANGE_) of _TYPE_;
	- _ACCESS_TYPE_.all-> 	access to the variables pointed byt the access type.
	
	- if ___ then ___ end if;
	- case ___ is
		when ___ => ; ...when ___ => ;
	  end case;
	- while ___ loop ___ end loop;
	- exception
		when ___ => ; ... when => ;
	
	- procedure ___ ( ___ : [in] [out] ___ ...) is
		...
	  begin
		...
	  end ____;
	- function ___ ( ___: [in] [out] ___ ...) return ___ is
		...
	  begin
		...
		return ____;
	  end ____;
	
	- ___ and [then] ___
	- ___ or ___

	--Alpha no serian solo A-Z, a-z y 0-9, siendo todo lo demas terminales?
	--** == elevado a ..
	Alpha= { '(', ')', '+', '*', '-', '/','%',':',';','"',''','=','>', '<','<=','>=','/=',':=','--',A-Z,a-z,0-9,'.',',','\n','\0'...
	T={while,loop, end loop, if, then, end if,else, elsif, is, array,range,of, type,new,record, end record,and, or,procedure,begin,end,
	 in, out, return, function}
	

	<Init> 		->	<Initfunc> | <InitProc>

--	<InitProc> 	->	procedure <Indentif_p> <Args> <Bloc_proc> --los args no son parte del indentificador?

	<InitProc> 	->	procedure <Indentif_p> <Bloc_proc>

	<Identif_p>	->	<Identif_proc> <Args> | <Identif_func> <Args> --Supongo que <Id_p> y <Id_f> se fusionaran con <Identif> 

	<Bloc_proc> 	->	<Declar> begin <Bloc_i> end <Identif_proc>;

--	<InitFunc> 	->	function <Identif_p> <Args> return <Terme> <Bloc_func> --idem cas <InitProc>

	<InitFunc> 	->	function <Identif_p> return <Terme> <Bloc_func>

	<Bloc_func> 	->	<Declar> begin <Bloc_i> return <Terme>; end <Identif_fun>;

	<Bloc_i> 	->	while <Cond> loop <Bloc_i> end loop;						|
				if <Cond> then <Bloc_i> end if;							|
				if <Cond> then <Bloc_i> else <Bloc_i> end if; 					|
				<Identif>:= <Terme>;<Bloc_i> 							|
				<Identif>:= <Terme>; 								|
				<Identif_p>;<Bloc_id>								|
				<Identif_p>;									|
				null;
	
	<Declar>	->	<Init> 										|
				<Declar_v/a>									|
				type <Identif> is <Declar_t> <Declar> 						|
				lambda	

	<Declar_v/a> 	->	<Identif>:<Tipus>;<Declar_v/a> | <Declar_2>,<Identif>:<Tipus>;<Declar_v/a>	|
				<Identif>: array (<Array_r>) of <Tipus>;<Declar_v/a> 				|
				null;

	<Declar_2>	->	<Declar_2>,<Identif> | <Identif>			

	<Declar_t>	->	record <Declar_v/a> end record; | new <Tipus>;

	<Array_r>	->	
				--Falta afegir la negacio
	<Cond>		->	(<Eval>) | <Eval> | not (<Eval>)

	<Eval>		->	<Expr> and <Cond> 								| 
				<Expr> and then <Cond> 								|
				<Expr> or <Cond> 								|
				<Expr>
	
	<Expr>		->	<Terme>'<'<Terme> 								|
				<Terme>'>'<Terme>								|
				<Terme>'<='<Terme>								|
				<Terme>'>='<Terme>								|
				<Terme>'='<Terme>								|
				<Terme>'/='<Terme>	
				<Terme>										|
				not <Terme>


	<Tipus>		->	integer | character | boolean
	
	<Args>		->	<Identif>: <I_O> <Tipus> | <Declar_2>,<Identif>: <I_O> <Tipus> | <Args_i>

	<Args_i>	->	<Identif>: <I_O> <Tipus>;<Args> | <Declar_2>,<Identif>: <I_O> <Tipus>;<Args>

	<I_O>		->	in | out | in out

	<Identif>	->	<Char_id>

	<Char_id>	->	(a..z)(A..Z) | <Dig_id>

	<Dig_id>	->	0..9 | <Char_id> | lambda

	<Terme>		->	<Fact> * <Fact> | <Fact> / <Fact> | <Fact> % <Fact> | <Fact>

	<Fact>		->	<Oper> + <Oper> | <Oper> - <Oper> | -<Oper> | <Oper>

	<Oper>		->	0 | 1..9<Oper_num>									|
				<Terme> | (<Terme>) 									|
				<Identif> | (<Identif>) 

	<Oper_num>	->	0..9 | 0..9<Oper_num>

